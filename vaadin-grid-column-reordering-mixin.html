<dom-module id="vaadin-grid-column-reordering-themability-styles">
  <template>
    <style>
      vaadin-grid-table[reordering] .vaadin-grid-cell {
        background: #000;
      }

      :host([reordering]) .vaadin-grid-cell[reorder-status="dragging"] {
        background: var(--primary-color, #000);
      }

      vaadin-grid-table[reordering] .vaadin-grid-cell:not([detailscell]) ::slotted(vaadin-grid-cell-content) {
        transition: opacity 300ms;
        transform: translateZ(0);
        opacity: 0.8;
      }

      #scroller .vaadin-grid-cell[reorder-status="allowed"] ::slotted(vaadin-grid-cell-content) {
        opacity: 1;
      }

      #scroller .vaadin-grid-cell[reorder-status="dragging"] {
        background: var(--primary-color, #000);
      }

      #scroller .vaadin-grid-cell[reorder-status="dragging"] ::slotted(vaadin-grid-cell-content) {
        opacity: 0.95;
      }
    </style>
  </template>
</dom-module>

<script>
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.Grid = window.Vaadin.Grid || {};

  /**
   * @polymerMixin
   */
  Vaadin.Grid.ColumnReorderingMixin = superClass => class ColumnReorderingMixin extends superClass {

    static get properties() {
      return {
        /**
         * Set to true to allow column reordering.
         */
        columnReorderingAllowed: {
          type: Boolean,
          value: false
        },

        _orderBaseScope: {
          type: Number,
          value: 10000000
        }
      };
    }

    static get observers() {
      return [
        '_updateOrders(_columnTree, _columnTree.*)'
      ];
    }

    ready() {
      super.ready();
      this.addEventListener('dragstart', this._onDragStart);
      this.addEventListener('dragover', this._onDragOver);
      this.addEventListener('dragend', this._onDragEnd);
      this.addEventListener('mouseover', this._onMouseOver);
      this.addEventListener('mouseout', this._onMouseOut);
    }

    _onMouseOver(e) {
      const cellContent = this._getCellContentByElement(e.target);
      if (!cellContent) {
        return;
      }
      const cell = this._getCellByCellContent(cellContent);
      if (this.$.header.contains(cell)) {
        cellContent.setAttribute('draggable', 'true');
      }
    }

    _onMouseOut(e) {
      const cellContent = this._getCellContentByElement(e.target);
      if (!cellContent) {
        return;
      }
      cellContent.removeAttribute('draggable');
    }

    _updateOrders(columnTree, splices) {
      if (columnTree === undefined || splices === undefined) {
        return;
      }

      // Set order numbers to top-level columns
      columnTree[0].forEach((column, index) => {
        column._order = (index + 1) * this._orderBaseScope;
      });
    }

    _onDragStart(e) {
      // We allow “dragstart” to start reordering only directly on
      // <vaadin-grid-cell-content> elements. Otherwise, any cell content with
      // `draggable="true"` attribute can start column reordering, issue #895.
      if (e.target.localName !== 'vaadin-grid-cell-content') {
        return;
      }

      const cell = this._getCellByCellContent(e.target);
      if (cell) {
        this.toggleAttribute('reordering', true);
        this._draggedColumn = cell._column;
        this._setSiblingsReorderStatus(this._draggedColumn, 'allowed');
        this._draggedColumn._reorderStatus = 'dragging';

        if (e.dataTransfer) {
          // Need to set any data to enable D&D on Firefox
          e.dataTransfer.setData('text', '');
          e.dataTransfer.effectAllowed = 'move';
        }

        this._autoScroller();
      }
    }

    _setSiblingsReorderStatus(column, status) {
      Array.prototype.filter.call(column.parentNode.children, child => {
        return /column/.test(child.localName) && this._isSwapAllowed(child, column);
      }).forEach(sibling => {
        sibling._reorderStatus = status;
      });
    }

    _onDragOver(e) {
      if (!this._draggedColumn) {
        // Reordering didn’t start. Skip this event.
        return;
      }

      // “dragover” can happen both on and inside <vaadin-grid-cell-content>,
      // so we look through the event path.
      const cellContent = e.composedPath().filter(el => {
        return el.localName === 'vaadin-grid-cell-content';
      })[0];
      if (!cellContent) {
        return;
      }

      e.preventDefault();
      const targetCell = this._getCellByCellContent(cellContent);
      const targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);

      if (targetColumn &&
        this._isSwapAllowed(this._draggedColumn, targetColumn) &&
        this._isSwappableByPosition(targetColumn, e.clientX)) {
        this._swapColumnOrders(this._draggedColumn, targetColumn);
      }

      this._lastDragClientX = e.clientX;
    }

    _autoScroller() {
      if (this._lastDragClientX) {
        const rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;
        const leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;

        if (rightDiff > 0) {
          this.$.table.scrollLeft += rightDiff / 10;
        } else if (leftDiff > 0) {
          this.$.table.scrollLeft -= leftDiff / 10;
        }
        this._scrollHandler();
      }

      if (this._draggedColumn) {
        this.async(this._autoScroller, 10);
      }
    }

    _onDragEnd(e) {
      if (!this._draggedColumn) {
        // Reordering didn’t start. Skip this event.
        return;
      }

      this.toggleAttribute('reordering', false);
      this._draggedColumn._reorderStatus = '';
      this._setSiblingsReorderStatus(this._draggedColumn, '');
      this._draggedColumn = null;
      this._lastDragClientX = null;
    }

    _isSwapAllowed(column1, column2) {
      if (column1 && column2) {
        const differentColumns = column1 !== column2;
        const sameParent = column1.parentElement === column2.parentElement;
        const sameFrozen = column1.frozen === column2.frozen;
        return differentColumns && sameParent && sameFrozen;
      }
    }

    _isSwappableByPosition(targetColumn, clientX) {
      const targetCell = Array.prototype.filter.call(this.$.header.querySelectorAll('.vaadin-grid-cell'), cell => {
        return cell._column === targetColumn;
      })[0];
      const sourceCellRect = this.$.header.querySelector('[reorder-status=dragging]').getBoundingClientRect();

      if (targetCell.getBoundingClientRect().left > sourceCellRect.left) {
        return clientX > targetCell.getBoundingClientRect().right - sourceCellRect.width;
      } else {
        return clientX < targetCell.getBoundingClientRect().left + sourceCellRect.width;
      }
    }

    _swapColumnOrders(column1, column2) {
      const _order = column1._order;
      column1._order = column2._order;
      column2._order = _order;
      this._updateLastFrozen();
      // this._updateLastColumn();
    }

    _getTargetColumn(targetCell, draggedColumn) {
      if (targetCell && draggedColumn) {
        let candidate = targetCell._column;
        while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {
          candidate = candidate.parentElement;
        }
        if (candidate.parentElement === draggedColumn.parentElement) {
          return candidate;
        } else {
          return targetCell._column;
        }
      }
    }

  };
</script>
