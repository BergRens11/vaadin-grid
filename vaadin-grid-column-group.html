<!--
@license
Copyright (c) 2017 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<!--

A `vaadin-grid-column-group` is used to wrap many columns under a common header. It supports nested groups.

The `class` attribute is used to differentiate header and footer templates.

#### Example:

    <vaadin-grid>
      <vaadin-grid-column-group>
        <template class="header">I'm in the group header</template>
        <template class="footer">I'm in the group footer</template>
        <vaadin-grid-column>
          <template class="header">I'm in the first header</template>
          <template>I'm in the first body cell</template>
          <template class="footer">I'm in the first footer</template>
        </vaadin-grid-column>
        <vaadin-grid-column>
          <template class="header">I'm in the second header</template>
          <template>I'm in the second body cell</template>
          <template class="footer">I'm in the second footer</template>
        </vaadin-grid-column>
      </vaadin-grid-column-group>
    </vaadin-grid>

-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="vaadin-grid-column.html">

<dom-module id="vaadin-grid-column-group">
  <script>
    {
      class GridColumnGroupElement extends Vaadin.Grid.ColumnBaseMixin(Polymer.Element) {

        static get is() {
          return 'vaadin-grid-column-group';
        }

        static get properties() {
          const ownProperties = {
            _childColumns: {
              value: function() {
                return this._getChildColumns(this);
              }
            },

            /**
             * Flex grow ratio for the column group as the sum of the ratios of its child columns.
             */
            flexGrow: {
              type: Number,
              readOnly: true
            },

            /**
             * Width of the column group as the sum of the widths of its child columns.
             */
            width: {
              type: String,
              readOnly: true
            },

            _visibleChildColumns: Array,

            /**
             * Represents the number of child columns of this group.
             */
            colSpan: {
              type: Number,
              readOnly: true
            },

            _rootColumns: Array
          }

          return Object.assign(ownProperties, super.properties);
        }

        static get observers() {
          return [
            '_updateVisibleChildColumns(_childColumns)',
            '_childColumnsChanged(_childColumns)',
            '_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells.*)',
            '_widthChanged(width, _headerCell, _footerCell, _cells.*)',
            '_frozenChanged(_childColumns, frozen, _headerCell)',
            '_hiddenChanged(hidden)',
            '_visibleChildColumnsChanged(_visibleChildColumns)',
            '_colSpanChanged(colSpan, _headerCell, _footerCell)',
            '_orderChanged(_order, _headerCell, _footerCell, _rootColumns)',
            '_reorderStatusChanged(_reorderStatus, _rootColumns)',
            '_resizableChanged(resizable, _rootColumns)'
          ];
        }

        // listeners: {
        //   'property-changed': '_columnPropChanged'
        // },

        connectedCallback() {
          this._updateFlexAndWidth(this._visibleChildColumns);
          this._addNodeObserver();
        }

        detached() {
          if (this._observer) {
            Polymer.dom(this).unobserveNodes(this._observer);
          }
        }

        _columnPropChanged(e) {
          if (e.detail.path === 'hidden') {
            this._preventHiddenCascade = true;
            this._updateVisibleChildColumns(this._childColumns);
            this._preventHiddenCascade = false;
          }

          if (/flexGrow|width|hidden|_childColumns/.test(e.detail.path)) {
            this._updateFlexAndWidth(this._visibleChildColumns);
          }

          if (e.detail.path === 'frozen') {
            // Don’t unfreeze the frozen group because of a non-frozen child
            this.frozen = this.frozen || e.detail.value;
          }

          if (e.detail.path === 'lastFrozen') {
            // Don’t unfreeze the frozen group because of a non-frozen child
            this._lastFrozen = this._lastFrozen || e.detail.value;
          }
        }

        _orderChanged(order, headerCell, footerCell, rootColumns) {
          if (order && rootColumns) {
            // The parent column order number cascades downwards to it's children
            // so that the resulting order numbering constructs as follows:
            // [             1000              ]
            // [     1100    ] | [     1200    ]
            // [1110] | [1120] | [1210] | [1220]

            // Trailing zeros are counted so we know the level on which we're working on.
            const trailingZeros = /(0+)$/.exec(order).pop().length;

            // In an unlikely situation where a group has more than 9 child columns,
            // the child scope must have 1 digit less...
            const childCountDigits = ~~(Math.log(rootColumns.length) / Math.log(Math.LN10)) + 1;

            // Final scope for the child columns needs to mind both factors.
            const scope = Math.pow(10, trailingZeros - childCountDigits);

            const _rootColumns = rootColumns.slice(0);
            if (_rootColumns[0] && _rootColumns[0]._order) {
              _rootColumns.sort((a, b) => {
                return a._order - b._order;
              });
            }

            [headerCell, footerCell].forEach(cell => {
              if (cell) {
                cell.style.order = order;
              }
            });

            _rootColumns.forEach((column, index) => {
              column._order = order + ((index + 1) * scope);
            });

            // this.fire('property-changed', {path: 'order', value: order});
          }
        }

        _reorderStatusChanged(reorderStatus, rootColumns) {
          if (reorderStatus === undefined || rootColumns === undefined) {
            return;
          }

          rootColumns.forEach(column => {
            column._reorderStatus = reorderStatus;
          });

          // this.fire('property-changed', {path: 'reorderStatus', value: reorderStatus});
        }

        _resizableChanged(resizable, rootColumns) {
          if (resizable === undefined || rootColumns === undefined) {
            return;
          }

          rootColumns.forEach(column => {
            column.resizable = resizable;
          });

          // this.fire('property-changed', {path: 'resizable', value: resizable});
        }

        _updateVisibleChildColumns(childColumns) {
          this._visibleChildColumns = Array.prototype.filter.call(childColumns, col => {
            return !col.hidden;
          });
        }

        _childColumnsChanged(childColumns) {
          if (!this._autoHidden && this.hidden) {
            Array.prototype.forEach.call(childColumns, column => {
              column.hidden = true;
            });
            this._updateVisibleChildColumns(childColumns);
          }
          // this.fire('property-changed', {path: '_childColumns', value: childColumns});
        }

        _updateFlexAndWidth(visibleChildColumns) {
          if (!visibleChildColumns) {
            return;
          }

          if (visibleChildColumns.length) {
            this._setWidth('calc(' + Array.prototype.reduce.call(visibleChildColumns, (prev, curr) => {
              return prev += ' + ' + (curr.width || '0px').replace('calc', '');
            }, '').substring(3) + ')');
          } else {
            this._setWidth('0px');
          }

          this._setFlexGrow(Array.prototype.reduce.call(visibleChildColumns, (prev, curr) => {
            return prev + curr.flexGrow;
          }, 0));
        }

        _frozenChanged(childColumns, frozen, headerCell) {
          if (childColumns === undefined || frozen === undefined) {
            return;
          }

          if (headerCell) {
            this._toggleAttribute('frozen', frozen, headerCell);
          }

          // Don’t propagate the default `false` value.
          // if (frozen !== false) {
            Array.prototype.forEach.call(childColumns, col => {
              // Don’t unfreeze the nested frozen groups
              // if (col.localName === 'vaadin-grid-column-group') {
              //   col.frozen = col.frozen || frozen;
              // } else {
                col.frozen = frozen;
              // }
            });

            // this.fire('property-changed', {path: 'frozen', value: frozen});
          // }

        }

        _hiddenChanged(hidden) {
          if (this._rootColumns && !this._preventHiddenCascade) {
            this._ignoreVisibleChildColumns = true;
            this._rootColumns.forEach(column => {
              column.hidden = hidden;
            });
            this._ignoreVisibleChildColumns = false;
          }

          // this.fire('property-changed', {path: 'hidden', value: hidden});
        }

        _visibleChildColumnsChanged(visibleChildColumns) {
          this._setColSpan(visibleChildColumns.length);

          if (!this._ignoreVisibleChildColumns) {
            if (visibleChildColumns.length === 0) {
              this._autoHidden = this.hidden = true;
            } else if (this.hidden && this._autoHidden) {
              this._autoHidden = this.hidden = false;
            }
          }
        }

        _colSpanChanged(colSpan, headerCell, footerCell) {
          if (headerCell) {
            headerCell.colSpan = colSpan;
          }
          if (footerCell) {
            footerCell.colSpan = colSpan;
          }
          // this.fire('property-changed', {path: 'colSpan', value: colSpan});
        }


        // TODO: Refactor the duplicate methods with DynamicColumnsBehavior.
        _getChildColumns(el) {
          return Polymer.dom(el).queryDistributedElements(
              'vaadin-grid-column, vaadin-grid-column-group, vaadin-grid-selection-column'
          );
        }

        _addNodeObserver() {
          this._observer = Polymer.dom(this).observeNodes(info => {
            const isColumnElement = node => {
              return (node.nodeType === Node.ELEMENT_NODE && /^vaadin-grid-(column|selection)/i.test(node.localName));
            };
            if (info.addedNodes.filter(isColumnElement).length > 0 ||
              info.removedNodes.filter(isColumnElement).length > 0) {
              this._rootColumns = this._getChildColumns(this);
              this._childColumns = this._rootColumns;
            }
          });
        }
      }

      customElements.define(GridColumnGroupElement.is, GridColumnGroupElement);

      /**
       * @namespace Vaadin
       */
      window.Vaadin = window.Vaadin || {};
      Vaadin.GridColumnGroupElement = GridColumnGroupElement;
    }
  </script>
</dom-module>
